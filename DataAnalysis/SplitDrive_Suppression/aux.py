import os
# import numpy as np
import aux
import MoNeT_MGDrivE as monet
# import matplotlib.pyplot as plt
# import matplotlib.patches as mpatches

PAD = '\n' + 125 * '*' + '\n'
(CRED, CEND) = ('\033[91m', '\033[0m')
###############################################################################
# Style
###############################################################################
STYLE_HLT = {
    "width": .075, "alpha": .15, "dpi": 500,
    "legend": True, "aspect": .5, "xRange": [0, 2000], "yRange": [0, 20000],
    "colors": ['#9f00cc', '#ec0b43', '#0038a8']
}
STYLE_HLT['aspect'] = monet.scaleAspect(.1, STYLE_HLT)

STYLE_ECO = {
    "width": .075, "alpha": .15, "dpi": 500,
    "legend": True, "aspect": .5, "xRange": [0, 2000], "yRange": [0, 1],
    "colors": [
            '#ff004d', '#80ff80', '#6600ff',
            '#e600ff', '#b3ccff', '#333380', '#f0a6ca'
        ]
}
STYLE_ECO['aspect'] = monet.scaleAspect(.1, STYLE_ECO)


###############################################################################
# Functions Definitions
###############################################################################
def getExperiments(PATH):
    dirs = sorted(next(os.walk(PATH))[1])
    temp = []
    for i in dirs:
        if(i != 'img'):
            temp.append(i)
    (expsNum, dirs) = (len(temp), temp)
    return (expsNum, dirs)


def selectAnalysisType(ECO, PATH_IMG):
    (PATH_HLT, PATH_ECO) = (PATH_IMG + 'hlt/', PATH_IMG + 'eco/')
    if ECO is True:
        (expType, style, path) = ('ECO', aux.STYLE_ECO, PATH_ECO)
    else:
        (expType, style, path) = ('HLT', aux.STYLE_HLT, PATH_HLT)
    return (expType, style, path)


def makeFolder(path):
    """Crates a folder in the specified directory.

    Parameters
    ----------
    path : string
        Path of the folder than needs to be created.

    Returns
    -------
    NA
    """
    if not os.path.exists(path):
        try:
            os.mkdir(path)
        except OSError:
            raise OSError(
                    "Can't create destination directory (%s)!" % (path)
                )


def normalizePopulationInNode(node, totalPopIx=-1, lociiScaler=1):
    """Auxiliary function that takes the population in a node and normalizes it
    to the total population (stored somewhere in the same pop-array, which is,
    ideally, the last column). Note that this function removes the 'totalPop'
    column as it is not relevant for analyses.

    Parameters
    ----------
    node : pop-numpyArray
        Population array without genotype header.
    totalPopIx : Integer (index)
        Column of the pop array where the total allele population is stored.
    lociiScaler : Integer
        Integer to scale the ratios appropriately to the number of locii in the
        genotypes.

    Returns
    -------
    type
        node

    """
    popSize = node[:, totalPopIx]
    normalizedNode = np.empty((node.shape[0], node.shape[1]-1))
    rangeElements = list(range(0, len(node[0])))
    rangeElements.pop(totalPopIx)
    for i in range(0, len(node), 1):
        with np.errstate(divide='ignore', invalid='ignore'):
            c = np.true_divide(node[i], popSize[i])
            c[~np.isfinite(c)] = 0
        normalizedNode[i] = lociiScaler * np.take(c, rangeElements)
    return normalizedNode


def normalizeLandscapeDataRepetitions(
            landscapeReps,
            totalPopIx=-1,
            lociiScaler=1
        ):
    """Normalizes the allele frequencies of landscape repetitions data to the
    total allele population (stored somewhere in the same pop-array, which is,
    ideally, the last column).


    Parameters
    ----------
    landscapeReps : landscapeReps dictionary
        Dictionary generated by monet.loadAndAggregateLandscapeDataRepetitions.
    totalPopIx : Integer (index)
        Column of the pop array where the total allele population is stored.
    lociiScaler : Integer
        Integer to scale the ratios appropriately to the number of locii in the
        genotypes.

    Returns
    -------
    type
        landscapeReps

    """
    landscapes = landscapeReps['landscapes']
    for (i, land) in enumerate(landscapes):
        landscapes[i] = [normalizePopulationInNode(node, totalPopIx=totalPopIx, lociiScaler=lociiScaler) for node in land]
    landscapeReps['landscapes'] = landscapes
    return landscapeReps
